import json
import pdb
import time

import requests
from bs4 import BeautifulSoup
from htmlrag import clean_html, build_block_tree, EmbedHTMLPruner, BM25HTMLPruner, GenHTMLPruner

from selenium import webdriver
from selenium.common import NoSuchElementException
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from dotenv import load_dotenv
import os
from selenium.webdriver.support.wait import WebDriverWait

from exceptions import AppliedSuccessfullyException
from utils import get_response_to_forms, fill_form_json, get_name_for_field

# Maximum number of words in a node when constructing the block tree for pruning with the embedding model
MAX_NODE_WORDS_EMBED = 10
# MAX_NODE_WORDS_EMBED = 256 # a recommended setting for real-world HTML documents
# Maximum number of tokens in the output HTML document pruned with the embedding model
MAX_CONTEXT_WINDOW_EMBED = 60
# MAX_CONTEXT_WINDOW_EMBED = 6144 # a recommended setting for real-world HTML documents
# Maximum number of words in a node when constructing the block tree for pruning with the generative model
MAX_NODE_WORDS_GEN = 5
# MAX_NODE_WORDS_GEN = 128 # a recommended setting for real-world HTML documents
# Maximum number of tokens in the output HTML document pruned with the generative model
MAX_CONTEXT_WINDOW_GEN = 32


# MAX_CONTEXT_WINDOW_GEN = 4096 # a recommended setting for real-world HTML documents


class SearchEngine:
    @staticmethod
    def find_all_elements_by_class(class_list, driver):
        css_selector = "." + ".".join(class_list)
        try:
            element = driver.find_element(By.CSS_SELECTOR, css_selector)
            return element
        except:
            pass

        for class_name in class_list:
            try:
                element = driver.find_element(By.CLASS_NAME, class_name)
                print(f"Found element with class: {class_name}")
                return element
            except NoSuchElementException:
                continue
        return None

    @staticmethod
    def process_html(html_content):
        # html = clean_html(html_content)
        bs = BeautifulSoup(html_content, 'html.parser')
        html = bs.prettify()

        block_tree, simplified_html = build_block_tree(html, max_node_words=MAX_NODE_WORDS_EMBED)
        return block_tree, simplified_html

    @staticmethod
    def fill_form_with_llm_response(driver, llm_response, user_data, submit=True):
        """
        Fills out a form on a webpage based on the JSON schema generated by an LLM.

        :param driver: Selenium WebDriver instance.
        :param llm_response: JSON schema as a string generated by the LLM.
        :param user_data: Dictionary mapping field names in the schema to user-provided values.
        :param submit: Whether to click the submit button after filling the form.
        """
        try:
            # pdb.set_trace()
            schema = json.loads(llm_response)
        except json.JSONDecodeError as e:
            raise ValueError("Invalid JSON schema from LLM response.") from e

        if not schema.get("properties"):
            raise ValueError("The JSON schema does not contain any properties.")

        for field_name, field_properties in schema["properties"].items():
            try:
                locator = field_properties.get("locator", {})
                element = None
                if "id" in locator:
                    element = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located((By.ID, locator["id"]))
                    )
                elif "class" in locator:
                    element = WebDriverWait(driver, 10).until(
                        EC.presence_of_element_located((By.CLASS_NAME, locator["class"]))
                    )
                else:
                    print(f"No valid locator provided for field: {field_name}")
                    continue

                if field_name in user_data:
                    element.clear()
                    element.send_keys(user_data[field_name])
                else:
                    print(f"No data provided for field: {field_name}")

            except Exception as e:
                print(f"Error interacting with field '{field_name}': {e}")

        if submit:
            try:
                submit_button = driver.find_element(By.TAG_NAME, "button")
                submit_button.click()
            except Exception as e:
                print(f"Error clicking the submit button: {e}")

    @staticmethod
    def fill_advanced_input(driver_, element, value):
        try:
            driver_.execute_script("arguments[0].style.visibility = 'visible'; arguments[0].style.height = 'auto';",
                                   element)
            element.send_keys(value)
            return True
        except:
            return False

    @staticmethod
    def extract_forms_from_url(url, htmlContent_from_response):
        try:
            # Analyzing the HTML from the URL (sending another request and analyze the response)
            # Handles a dynamic HTML page case.
            html_content = SearchEngine.get_full_content(url)
            forms_data_from_url = SearchEngine.analyze_html_content(html_content)

            # In addition, analyzing the specific HTML from the response
            # Handling all other cases.
            form_data_from_html_response = SearchEngine.analyze_html_content(htmlContent_from_response)
            forms_data_from_url.extend(form_data_from_html_response)

            return forms_data_from_url
        except AppliedSuccessfullyException:
            raise
        except Exception as e:
            print(f"Error fetching data: {e}")
            return None

    @classmethod
    def get_full_content(cls, url):
        driver = webdriver.Chrome()
        driver.get(url)
        time.sleep(3)
        # Scroll down to the bottom
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(3)
        html_content = driver.page_source
        if cls.apply_manually(html_content, driver):
            res = input("Press the submit!")
            if not 'no' in res:
                raise AppliedSuccessfullyException

        driver.quit()
        return html_content

    @classmethod
    def get_forms(cls, html_content, field):
        soup = BeautifulSoup(html_content, "html.parser")
        forms_data = []
        # If 'field' is 'iframe', handle iframe extraction
        if field == "iframe":
            for iframe in soup.find_all("iframe"):
                src = iframe.get("src")
                if src:
                    try:
                        # Fetch the iframe content
                        response = requests.get(src)
                        if response.status_code == 200:
                            html = SearchEngine.get_full_content(src)
                            iframe_soup = BeautifulSoup(html, "html.parser")
                            # Extract forms from the iframe content
                            forms_data.extend(cls._extract_forms_from_soup(iframe_soup))
                    except AppliedSuccessfullyException:
                        raise
                    except Exception as e:
                        print(f"Error fetching iframe content from {src}: {e}")
        elif field == "div":
            apply_divs = set()
            divs = soup.find_all("div")
            print(f"Found {len(divs)} divs in the page")
            for div in divs:
                if cls.is_form_div(div):
                    apply_divs.add(div)
                    print(f"Add another potential job-div, currently {len(apply_divs)} in the set")
            # pdb.set_trace()
            forms_data.extend(cls._extract_forms_from_soup(apply_divs=list(apply_divs), type_="div", soup=soup))
        else:
            forms_data.extend(cls._extract_forms_from_soup(soup))
        return forms_data

    @staticmethod
    def _extract_forms_from_soup(soup, type_="form", apply_divs=None):
        forms_data = []
        if type_ == 'form':
            data = soup.find_all(type_)
        else:
            data = soup.find_all(type_) if apply_divs is None else apply_divs

        for element in data:
            form_details = {
                "action": element.get("action") if element.get("action") else '',
                "method": element.get("method", "get").lower() if element.get("method", "get").lower() else '',
                "fields": [],
            }
            for input_tag in element.find_all(["input", "textarea", "select"]):
                if input_tag.get("type") == "hidden":
                    continue

                field_data = {
                    "name": input_tag.get("name") if input_tag.get("name") else "None",
                    "type": input_tag.get("type", "text"),
                    "id": input_tag.get("id"),  # Capture the 'id' attribute
                    "class": input_tag.get("class"),  # Capture the 'class' attribute (returns a list)
                    "label": None,  # Will be populated if a label is found
                    "value": input_tag.get("value", ""),
                    "placeholder": input_tag.get("placeholder", ""),
                }
                if "id" in input_tag.attrs:
                    label = soup.find("label", {"for": input_tag["id"]})
                    if label:
                        field_data["label"] = label.get_text().strip()
                form_details["fields"].append(field_data)

            submit_buttons = [
                {
                    "text": btn.get_text().strip(),
                    "id": btn.get("id"),
                    "class": btn.get("class"),
                }
                for btn in element.find_all("button", {"type": "submit"})
            ]
            form_details["submit_buttons"] = submit_buttons

            forms_data.append(form_details)

        return forms_data

    @classmethod
    def analyze_html_content(cls, html_content):
        forms_data = SearchEngine.get_forms(html_content, field='form')
        forms_from_iframes = SearchEngine.get_forms(html_content, field='iframe')
        forms_from_divs = SearchEngine.get_forms(html_content, field='div')
        forms_data.extend(forms_from_iframes)
        forms_data.extend(forms_from_divs)
        return forms_data

    @classmethod
    def apply_manually(cls, html_content, driver):
        forms = cls.get_forms(html_content, "form")
        forms_from_divs = cls.get_forms(html_content, field='div')
        forms.extend(forms_from_divs)
        if len(forms) > 0:
            response = get_response_to_forms(forms, "analyze")
            fill_form_json(response)
            if cls.apply(response, driver):
                return True
        return False

    @classmethod
    def apply(cls, response, driver):
        filled_count = 0
        for form_element in response:
            fields = form_element['fields']
            for field in fields:
                try:
                    is_filled = False
                    name = field['name']
                    val = field['value']
                    field_id = field['id']
                    field_classname = field['class']  # Probably an array
                    field_element_by_id = cls.get_field_by_id(field_id=field_id, driver_=driver)
                    if field_element_by_id:
                        is_filled = cls.try_send_keys(element=field_element_by_id, val=val, name=name, driver=driver)
                    else:
                        field_element_by_classname = cls.find_all_elements_by_class(field_classname, driver)
                        if field_element_by_classname:
                            is_filled = cls.try_send_keys(element=field_element_by_classname, val=val, name=name,
                                                          driver=driver)
                    if is_filled:
                        print(f"Element {name} filled successfully with {val}")
                        filled_count += 1
                        time.sleep(1)
                    else:
                        print(f"Element {name} isn't filled with {val}")
                except:
                    # type_ = field['type']
                    # if type_.lower() in ['radio','input']:
                    #     #TODO: HANDLE FILL THESE FIELDS MANUALLY!
                    continue
        return filled_count > 4

    @classmethod
    def fill_resume_field(cls, field_element_by_id, value,
                          local_resume_filepath=r"C:\Users\אביב\Desktop\works\resume\aviv_nataf_resume.pdf"):
        vals = [value, local_resume_filepath]
        for val in vals:
            try:
                field_element_by_id.send_keys(val)
                return True
            except:
                continue
        return False

    @classmethod
    def try_send_keys(cls, element, val, name, driver):
        filled = False
        try:
            if name.lower() in ['cv', 'resume_url', 'resume']:
                filled = cls.fill_resume_field(element, val)
            elif element.get_attribute("type") == "checkbox":
                filled = cls.toggle_checkbox(element, val)
            else:
                element.send_keys(val)
                filled = True
            return filled
        except:
            return cls.fill_advanced_input(driver, element, val)

    @classmethod
    def get_field_by_id(cls, field_id, driver_):
        try:
            if field_id:
                field_element_by_id = driver_.find_element(By.ID, field_id)
                return field_element_by_id
            return None
        except:
            return None

    @classmethod
    def toggle_checkbox(cls, element, val):
        try:
            is_checked = element.is_selected()
            # Check or uncheck based on the desired value
            if (val and not is_checked) or (not val and is_checked):
                element.click()  # Toggle the checkbox
            return True
        except:
            return False

    @classmethod
    def is_form_div(cls, div):
        keywords = {"apply", "job", "application", "form"}

        # Check if any keyword exists in the div's ID
        id_condition = div.get("id") and any(keyword in div.get("id").lower() for keyword in keywords)

        # Check if any keyword exists in the div's class names
        class_condition = div.get("class") and any(
            keyword in cls_name.lower() for cls_name in div.get("class", []) for keyword in keywords
        )

        # Check if any keyword exists in the visible text content of the div
        text_condition = " ".join(div.stripped_strings).lower() and any(
            keyword in " ".join(div.stripped_strings).lower() for keyword in keywords
        )

        return id_condition or class_condition or text_condition
